# Supabase PostgREST Client for Rust

A Rust client library for Supabase PostgreSQL REST API access.

## Features

- Basic CRUD operations (`select`, `insert`, `update`, `delete`)
- Filtering (`eq`, `gt`, `lt`, etc.)
- Ordering and pagination
- Transactions
- RPC function calls
- CSV export
- TypeScript to Rust type conversion (with `schema-convert` feature)
- Type-safe database operations

## Project Status & Roadmap

**Current Status:** Alpha (v0.1.3) - Core API Ready

This crate provides core PostgREST functionality and type generation. It is under active development.

**Roadmap:**

*   [ ] Enhanced filtering options (e.g., full-text search, JSONB operations)
*   [ ] Support for more complex `select` queries (e.g., nested resources)
*   [ ] Improved error reporting and handling
*   [ ] Comprehensive integration tests against a live Supabase instance
*   [ ] Explore potential state machine usage for request building/transaction management

## Installation

Add the dependency to your Cargo.toml:

```toml
[dependencies]
supabase-rust-postgrest = "0.1.3"
```

To use the TypeScript to Rust type conversion feature:

```toml
[dependencies]
supabase-rust-postgrest = { version = "0.1.3", features = ["schema-convert"] }
```

## Basic Usage

```rust
use supabase_rust_postgrest::PostgrestClient;
use reqwest::Client;

async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let http_client = Client::new();
    let db = PostgrestClient::new(
        "https://your-project.supabase.co", 
        "your-anon-key", 
        "your_table", 
        http_client
    );
    
    // Fetch data
    let response: Vec<serde_json::Value> = db
        .select("*")
        .eq("column", "value")
        .execute()
        .await?;
    
    // Insert data
    let data = serde_json::json!({
        "name": "John Doe",
        "email": "john@example.com"
    });
    
    let inserted = db
        .insert(&data)
        .await?;
        
    // Update data
    let update_data = serde_json::json!({
        "name": "Jane Doe"
    });
    
    let updated = db
        .eq("id", "1")
        .update(&update_data)
        .await?;
        
    // Delete data
    let deleted = db
        .eq("id", "1")
        .delete()
        .await?;
        
    Ok(())
}
```

## TypeScript to Rust Type Conversion

This crate provides functionality to convert TypeScript type definitions generated by Supabase's `supabase gen types typescript` command into Rust types. To use this feature, you must enable the `schema-convert` feature.

**Note:** While the infrastructure and CLI tools for schema conversion are present, the core logic (`convert_typescript_to_rust` function) that performs the detailed type mapping from TypeScript interfaces/types to Rust structs/enums is currently a placeholder and requires further implementation based on specific project needs or more sophisticated parsing. The current implementation primarily sets up the file structure and basic generation.

### Converting Using Make (Recommended)

The simplest way to generate Rust types from your Supabase schema is using the provided Makefile:

```bash
# Copy the Makefile from this repository to your project root
# Then run:
make gen-types-rust
```

This will:
1. Generate TypeScript types using `supabase gen types typescript`
2. Convert them to Rust types
3. Place the generated Rust file in `src/generated/schema.rs`

You can customize the output location and module name:

```bash
make gen-types-rust TYPES_OUTPUT_DIR=src/models MODULE_NAME=database
```

For more options, run:

```bash
make help
```

### Converting from Command Line

```bash
# Run in your repository root directory
supabase gen types typescript > types.ts

# Generate Rust types from TypeScript definitions
cargo run --features schema-convert --bin supabase-gen-rust -- \
    --input-file ./types.ts \
    --output-dir ./src/generated \
    --module-name schema
```

### Converting Programmatically

```rust
use std::path::Path;
use supabase_rust_postgrest::{
    convert_typescript_to_rust,
    SchemaConvertOptions,
};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let input_file = Path::new("./types.ts");
    let options = SchemaConvertOptions::default();
    
    let output_path = convert_typescript_to_rust(input_file, options)?;
    println!("Generated Rust types at: {:?}", output_path);
    
    Ok(())
}
```

## Type-Safe Database Operations

You can use the generated Rust types for type-safe database operations:

```rust
use serde::{Deserialize, Serialize};
use supabase_rust_postgrest::{
    PostgrestClient, Table, PostgrestClientTypeExtension
};

// When using auto-generated models:
// mod schema; 
// use schema::*;

#[derive(Debug, Clone, Serialize, Deserialize)]
struct User {
    id: Option<i32>,
    name: String,
    email: String,
}

impl Table for User {
    fn table_name() -> &'static str {
        "users"
    }
}

async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let http_client = reqwest::Client::new();
    let client = PostgrestClient::new(
        "https://your-project.supabase.co", 
        "your-anon-key", 
        "", // Table name is set automatically
        http_client
    );
    
    // Type-safe query
    let users: Vec<User> = client
        .query_typed::<User>()
        .eq("name", "John")
        .execute()
        .await?;
        
    // Type-safe insert
    let new_user = User {
        id: None,
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    };
    
    let inserted: User = client
        .insert_typed(&new_user)?
        .execute()
        .await?;
        
    // Type-safe update
    let mut user_to_update = users[0].clone();
    user_to_update.name = "Bob".to_string();
    
    let updated: User = client
        .update_typed(&user_to_update)?
        .eq("id", &user_to_update.id.unwrap().to_string())
        .execute()
        .await?;
        
    // Type-safe delete
    client
        .delete_typed::<User>()
        .eq("id", &users[0].id.unwrap().to_string())
        .execute()
        .await?;
        
    Ok(())
}
```

## Testing

To run the tests for this crate, including feature-specific tests:

```bash
cargo test --all-features
```

We aim for high test coverage, particularly for core CRUD and filtering operations. Integration tests using `wiremock` simulate responses from the PostgREST API.

## Security Considerations

*   **API Keys:** Ensure your Supabase URL and `anon` key (or `service_role` key if used) are stored and handled securely. Avoid hardcoding them directly in your source code. Consider using environment variables or a secrets management solution.
*   **Input Validation:** While this library promotes type safety, always validate user-provided input before constructing database queries, especially for filter values, to prevent potential injection issues or unintended data access.

## Contributing

Contributions are welcome! Please feel free to open an issue or submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

Ensure that your contributions pass all tests (`cargo test --all-features`) and adhere to the project's coding style (run `cargo fmt`).

## License

MIT 